;; -*- mode:lisp; syntax:common-lisp; package:cl-user -*-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; system: 	U I - L I B;;;; file: 	view-extensions.lisp;; author: 	Adam Alpern (ala@neural.hampshire.edu);; created: 	03/02/95;;;; Copyright © 1995 Adam Alpern;;;; Please send comments, improvements, or whatever to ala@neural.hampshire.edu.;; If you redistribute this file, please keep this header intact, and;; please send me any changes. I would like to know if you use this utility,;; and if you find it useful.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Revision History;; ----------------;; 7/9/96	- offset-view lambda list now matches set-view-xxx (h &optional v);; 8/5/95	- added draw-centered-text;;  6/27/95	- added with-view-rect, works just like ccl::with-item-rect.;; 03/02/95	- File created.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require :quickdraw)(require :loop)(in-package :cl-user)(defmacro fast-paint-rect (left &optional top right bot color)  "A version of PAINT-RECT that does not focus the view -- should onlybe called within a WITH-FOCUSED-VIEW."  `(with-fore-color ,color    (ccl::with-rectangle-arg (r ,left ,top ,right ,bot) (#_PaintRect r))))(defmacro with-view-rect ((name view) &body body)  (let ((topleft (gensym))        (bottomright (gensym)))    `(multiple-value-bind (,topleft ,bottomright)                          (view-corners ,view)       (rlet ((,name :rect                     :topleft ,topleft                     :bottomright ,bottomright))         ,@body))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; thing:	misc view utils;; synopsis: 	A number of handy macros and functions to do oft-done things.(defmacro view-size-h (view)  "Get the horizontal size of view."  `(point-h (view-size ,view)))(defmacro view-size-v (view)  "Get the vertical size of view."  `(point-v (view-size ,view)))(defmacro view-position-h (view)  "Get the horizontal position of view."  `(point-h (view-position ,view)))(defmacro view-position-v (view)  "Get the vertical position of view."  `(point-v (view-position ,view)))(defmacro set-view-h-size (view h)  "Set the horizontal size of view."  `(set-view-size ,view ,h (view-size-v ,view)))(defmacro set-view-v-size (view v)  "Set the vertical size of view."  `(set-view-size ,view (view-size-h ,view) ,v))(defmacro set-view-h-position (view h)  "Set the horizontal position of view."  `(set-view-position ,view ,h (view-position-v ,view)))(defmacro set-view-v-position (view v)  "Set the verticval position of view."  `(set-view-position ,view (view-position-h ,view) ,v)); for consistency(defmacro set-view-size-h (view h)  "Set the horizontal size of view."  `(set-view-size ,view ,h (view-size-v ,view)))(defmacro set-view-size-v (view v)  "Set the vertical size of view."  `(set-view-size ,view (view-size-h ,view) ,v))(defmacro set-view-position-h (view h)  "Set the horizontal position of view."  `(set-view-position ,view ,h (view-position-v ,view)))(defmacro set-view-position-v (view v)  "Set the verticval position of view."  `(set-view-position ,view (view-position-h ,view) ,v))(defun offset-view (view h &optional v)  (set-view-position    view    (add-points (if v (make-point h v) h) (view-position view))))(defmethod bottom-right ((self simple-view))  (let ((dp (view-position self))        (s  (view-size self)))    (make-point (+ (point-h dp) (point-h s))                (+ (point-v dp) (point-v s)))))(defmethod bottom-right ((self view))  (view-size self))(defun upper-left (point-1 point-2)  "Returns the upper left hand point of the rectangle defined by the points point-1 and point-2"  (let ((x1 (point-h point-1)) (y1 (point-v point-1))        (x2 (point-h point-2)) (y2 (point-v point-2)))    (make-point (if (< x1 x2) x1 x2)                (if (< y1 y2) y1 y2))))(defun lower-right (point-1 point-2)  "Returns the bottom right hand point of the rectangle defined by the points point-1 and point-2"  (let ((x1 (point-h point-1)) (y1 (point-v point-1))        (x2 (point-h point-2)) (y2 (point-v point-2)))    (make-point (if (> x1 x2) x1 x2)                 (if (> y1 y2) y1 y2))))(defmacro view-center (item)  `(multiply-point (view-size ,item) .5))(defun linebetw (p1 p2)  "Draws a line between p1 and p2. Should always be called within a (with-focused-view...since it does not focuse the view. Appropriate pen settings should be done priorto calling linebetw as well."  (#_moveto :long p1)  (#_lineto :long p2))(defun line-height (font-name font-size)  (multiple-value-bind (ascent descent maxwidth leading)                       (font-info (list font-name                                        font-size))    (declare (ignore maxwidth))    (+ ascent descent leading)))(defmethod draw-string ((item simple-view) the-string where)  (with-font-focused-view item    (with-pstrs ((p-title the-string))      (#_MoveTo :long        (add-points where                    (make-point                     0                     (line-height (car (view-font item))                                 (cadr (view-font item))))))      (#_DrawString :ptr p-title))))(defun subviews-in-rect (view top-left bottom-right)  "Takes a view and the topleft and bottomright coordinatesof a rectagle and returns a list of the subviews whoseview-position is within that rectangle."  (let ((rect (make-record :rect))        (views nil))    (points-to-rect top-left bottom-right rect)    (do-subviews (subview view)      (when (point-in-rect-p rect (view-position subview))        (push subview views)))    views));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; thing:	draggable views;; synopsis: 	Methods for resizing and moving views within another view.(defmethod drag-rect ((self view) &optional (start (view-mouse-position self))                      (pos (view-mouse-position self)))  (with-pen-saved    (ccl::set-pen-mode self :patxor)    (ccl::set-pen-pattern self *gray-pattern*)    (let ((rect (make-record :rect))          p1 p2)      (setf p1 (view-mouse-position self))      (setf p2 p1)      (loop        (setf p2 (view-mouse-position self))        (cond ((mouse-down-p)               (unless (= p1 p2)                 (points-to-rect start pos rect)                 (frame-rect self rect)                 (setf pos (add-points pos (subtract-points p2 p1)))                 (setf p1 p2)                 (points-to-rect start pos rect)                 (frame-rect self rect))               )              (t (points-to-rect start pos rect)                 (frame-rect self rect)                 (return t))))      (ccl::set-pen-mode self :patCopy)      (ccl::set-pen-pattern self *black-pattern*)      (points-to-rect start pos rect))))(defmethod drag-view-position ((self simple-view) (container view) &optional other-views)  (with-pen-saved    (ccl::set-pen-mode container :patxor)    (ccl::set-pen-pattern self *gray-pattern*)    (let* ((size (view-size self))           (view-pos (view-position self))           (p1 (view-mouse-position container))           (p2 p1)           (delta #@(0 0)))      (declare (fixnum p1  p2 view-pos size delta)               (dynamic-extent p1 p2 size view-pos delta))      (loop        (setf p2 (view-mouse-position container))        (cond ((mouse-down-p)               (unless (= p1 p2)                 (frame-rect container (add-points view-pos delta)                              (add-points (add-points view-pos delta) size))                 (dolist (v other-views)                   (frame-rect container (add-points (view-position v) delta)                                (add-points (add-points (view-position v) delta) (view-size v))))                 (setf delta (add-points delta (subtract-points p2 p1)))                 (setf p1 p2)                 (frame-rect container (add-points view-pos delta)                              (add-points (add-points view-pos delta) size))                 (dolist (v other-views)                   (frame-rect container (add-points (view-position v) delta)                                (add-points (add-points (view-position v) delta) (view-size v)))))               )              (t (return t))))      (ccl::set-pen-pattern self *black-pattern*)      (ccl::set-pen-mode container :patCopy)      (unless (= delta #@(0 0))        (set-view-position self (add-points (view-position self) delta))        (dolist (v other-views)          (set-view-position v (add-points (view-position v) delta)))))))(defmethod drag-view-size ((self simple-view) (container view))    (let ((new-rect (drag-rect container (view-position self)                             (bottom-right self))))    (cond ((empty-rect-p new-rect) nil)          (t           (unless (= (view-position self)                       (rref new-rect :rect.topleft))             (set-view-position self (rref new-rect :rect.topleft)))           (set-view-size self                           (subtract-points                            (rref new-rect :rect.bottomright)                           (rref new-rect :rect.topleft)))))    (dispose-record new-rect))  (view-draw-contents self))(defmethod draw-centered-text ((view simple-view) text)    (with-focused-view view    (with-returned-pstrs ((s text))      (multiple-value-bind (ascent descent max-width leading)                           (font-info (view-font view))        (declare (ignore max-width))        (let* ((textHeight (+ ascent descent leading))               (width (string-width text (view-font view)))               (h (point-h (view-size view)))               (v (point-v (view-size view)))               (left (truncate (/ (- h width) 2)))               (top  (truncate (/ (- v textHeight) 2))))          (#_MoveTo left (+ top ascent))                    (with-fore-color (or (part-color view :text) 0)            (#_DrawString s)))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; thing:	rubber band lines;; synopsis: 	draw and update a line between the mouse-click point;;           	and the current location of the mouse, as long as the;;           	mouse is down. Return the view under the mouse when the;;	     	button is released.;; 06/09/95 ala - added the-container keyword, so you may optionally;;		  supply a view to do the drawing in.(defmethod draw-rubber-band-line ((view view) point                                   &key                                   (color *gray-color*)                                  (width 1)                                  the-container)  (let ((container (if the-container                      the-container                     (view-container view)))        where old targetpt)    (setq where (add-points point (view-position view)))    (setq old where)    (with-focused-view container      (with-fore-color color        (with-pen-saved          (set-pen-pattern container *black-pattern*)          (#_pensize width width)          (#_penmode (ccl::mode-arg :patxor))          (loop while (mouse-down-p)                do (unless (equal old (view-mouse-position container))                     (linebetw where old)                     (linebetw where (view-mouse-position container))                     (setq old (view-mouse-position container)))                finally (progn                          (linebetw where (view-mouse-position container))                          (linebetw where where)                          (setq targetpt (view-mouse-position container)))))))    (values (find-view-containing-point container targetpt)            targetpt)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; thing:	selection rect;; synopsis:	(defmethod drag-selection-rect ((self view) where)  "Draw a selection rectangle following the mouse (ala finder, et al)and return the upper-left and lower-right coordinates of the selectedrect as 2 values."  (with-focused-view self    (with-pen-saved      (let* ((click-origin (view-mouse-position self))             (p1 click-origin) (p2 p1))        (set-pen-mode self :patXor)        (set-pen-pattern self *gray-pattern*)        (loop          (setf p2 (view-mouse-position self))          (cond ((mouse-down-p)                 (unless (= p1 p2)                   (frame-rect self                               (upper-left click-origin p2)                               (lower-right click-origin p2))                   (frame-rect self                               (upper-left click-origin p1)                               (lower-right click-origin p1))                   (setf p1 p2)))                (t (return t))))        (pen-normal self)        (cond ((= p2 click-origin) nil)              (t (with-fore-color *white-color*                    (frame-rect self                               (upper-left click-origin p2)                               (lower-right click-origin p2)))                 (view-draw-contents self)                 (values (upper-left click-origin p2)                         (lower-right click-origin p2))))))));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defclass drag-position-mixin () ())(defmethod view-click-event-handler :after ((view drag-position-mixin)                                             where)  (declare (ignore where))  (drag-view-position view (view-container view)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; thing:	make-view-matrix;;		make-view-matrix-array;; synopsis:	(defun make-view-matrix (class x y size offset hspace vspace &rest options)  "Returns a list of views of the provided class, laid out in anx by y grid. hspace and vspace determine the amount of space betweenviews. offset is the view-position of the upper-left view.The &rest argument may be used to supply other keyword argumentsto me used as arguments to make-instance."  (let ((size-h (point-h size))        (size-v (point-v size))         (view-list nil))    (setq size (make-point size-h size-v))    (dotimes (xx x)      (dotimes (yy y)        (push (apply #'make-instance                     class                     :view-size size                     :view-position (add-points                                      offset                                     (make-point (* (+ hspace size-h) xx)                                                  (* (+ vspace size-v) yy)))                     options)              view-list)))    view-list))(defun make-view-matrix-array (class x y size offset hspace vspace &rest options)  "Returns 2 values: list of views of the provided class, laid out in anx by y grid, and an array of dimensions x by y, containing the views.hspace and vspace determine the amount of space between views. offset is the view-position of the upper-left view. The &rest argument may be used to supply other keyword arguments to me used as arguments to make-instance."  (let ((size-h (point-h size))        (size-v (point-v size))         (view-list nil)        (view-array (make-array (list x y))))    (setq size (make-point size-h size-v))    (dotimes (xx x)      (dotimes (yy y)        (let ((view (apply #'make-instance                           class                           :view-size size                           :view-position (add-points                                            offset                                           (make-point (* (+ hspace size-h) xx)                                                        (* (+ vspace size-v) yy)))                           options)))          (push view view-list)          (setf (aref view-array xx yy) view)          )))    (values view-list view-array)));;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; thing:;; author: Jim Carlson(defun sqr (num)  (* num num))(defun multiply-point (point num)  (make-point   (round (* num (point-h point)))   (round (* num (point-v point)))))(defun midpoint (p1 p2)  (make-point (+ (point-h p2) (round (/ (- (point-h p1) (point-h p2)) 2)))              (+ (point-v p2) (round (/ (- (point-v p1) (point-v p2)) 2)))))(defun distance-along-line (start-point end-point distance)  "Returns the point along the line defined by the first two arguments that is the distance in pixels specified in the third argument from the first point in the line.  This function will return nil if the line isshorter than the desired distance, rather than signaling an error."  (if (> distance (distance-between-two-points start-point end-point)) nil      (let* ((x1 (point-h start-point)) (y1 (point-v start-point))             (x2 (point-h end-point)) (y2 (point-v end-point))             (a (- y2 y1)) (b (- x1 x2))             (ratio (/ distance (sqrt (+ (sqr a) (sqr b))))))        (make-point (round (+ x2 (* ratio b))) (round (- y2 (* ratio a)))))))(defun distance-between-two-points (point1 point2)  "Gives the distance in pixels (rounded) between the encoded points point1 and point2."  (round (sqrt (+ (sqr (- (point-h point2) (point-h point1)))                  (sqr (- (point-v point2) (point-v point1)))))))